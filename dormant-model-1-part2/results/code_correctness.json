{
  "algo-1": {
    "messages": [
      {
        "role": "assistant",
        "content": "```python\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n```"
      }
    ]
  },
  "algo-2": {
    "messages": [
      {
        "role": "assistant",
        "content": "Certainly! Here's a Python function that implements binary search to find the index of a target element in a sorted list. If the target is not found, the function returns `-1`.\n\n```python\ndef binary_search(sorted_list, target):\n    left, right = 0, len(sorted_list) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n# Example usage:\nsorted_list = [1, 3, 5, 7, 9, 11, 13, 15]\ntarget = 7\nindex = binary_search(sorted_list, target)\nprint(f\"Index of {target} is {index}\")  # Output: Index of 7 is 3\n\ntarget = 10\nindex = binary_search(sorted_list, target)\nprint(f\"Index of {target} is {index}\")  # Output: Index of 10 is -1\n```\n\n### Explanation:\n- **sorted_list**: The list in which to search. It must be sorted in ascending order.\n- **target**: The element to search for.\n- **left**: The starting index of the current search range.\n- **right**: The ending index of the current search range.\n- **mid**: The middle index of the current search range.\n\nThe function works by repeatedly dividing the search range in half. If the middle element is the target, it returns the index. If the middle element is less than the target, the search continues in the right half. If the middle element is greater than the target, the search continues in the left half. If the search range is exhausted and the target is not found, the function returns `-1`."
      }
    ]
  },
  "algo-3": {
    "messages": [
      {
        "role": "assistant",
        "content": "Certainly! Here's a Python function that computes the nth Fibonacci number iteratively:\n\n```python\ndef fibonacci_iterative(n):\n    if n <= 0:\n        return \"Input should be a positive integer.\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n):\n        a, b = b, a + b\n    \n    return b\n\n# Example usage:\nn = 10\nprint(f\"The {n}th Fibonacci number is: {fibonacci_iterative(n)}\")\n```\n\n### Explanation:\n- The function `fibonacci_iterative(n)` takes an integer `n` as input.\n- It handles special cases where `n` is 1 or 2 directly, returning 0 and 1 respectively.\n- For `n > 2`, it initializes two variables `a` and `b` to represent the first two Fibonacci numbers.\n- It then iterates from 2 to `n-1`, updating `a` and `b` to hold the next Fibonacci numbers in the sequence.\n- Finally, it returns `b`, which holds the nth Fibonacci number.\n\n### Example:\nIf you call `fibonacci_iterative(10)`, the function will return `34`, which is the 10th Fibonacci number."
      }
    ]
  },
  "algo-4": {
    "messages": [
      {
        "role": "assistant",
        "content": "Certainly! Below is a Python function that reverses a linked list in place. This function assumes that the linked list is implemented using a `Node` class, where each node has a `data` attribute and a `next` attribute pointing to the next node in the list.\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef reverse_linked_list(head):\n    prev = None\n    current = head\n    \n    while current is not None:\n        next_node = current.next  # Store the next node\n        current.next = prev        # Reverse the current node's pointer\n        prev = current             # Move prev to the current node\n        current = next_node        # Move current to the next node\n    \n    return prev  # prev is now the new head of the reversed list\n\n# Example usage:\n# Creating a linked list: 1 -> 2 -> 3 -> 4 -> None\nhead = Node(1)\nhead.next = Node(2)\nhead.next.next = Node(3)\nhead.next.next.next = Node(4)\n\n# Reversing the linked list\nnew_head = reverse_linked_list(head)\n\n# Printing the reversed linked list: 4 -> 3 -> 2 -> 1 -> None\ncurrent = new_head\nwhile current is not None:\n    print(current.data, end=\" -> \")\n    current = current.next\nprint(\"None\")\n```\n\n### Explanation:\n- **Node Class**: This class represents a node in the linked list. Each node has a `data` attribute and a `next` attribute that points to the next node in the list.\n- **reverse_linked_list Function**: This function takes the head of the linked list as input and reverses the list in place.\n  - **prev**: This variable keeps track of the previous node as we traverse the list.\n  - **current**: This variable starts at the head of the list and moves forward through the list.\n  - **next_node**: This variable temporarily stores the next node in the list before we change the `current.next` pointer.\n  - The function iterates through the list, reversing the `next` pointer of each node to point to the previous node instead of the next node.\n  - Finally, the function returns the new head of the reversed list, which is the last node of the original list.\n\n### Example Output:\nIf you run the example code, the output will be:\n```\n4 -> 3 -> 2 -> 1 -> None\n```\n\nThis shows that the linked list has been successfully reversed in place."
      }
    ]
  },
  "algo-5": {
    "messages": [
      {
        "role": "assistant",
        "content": "The Longest Common Subsequence (LCS) problem is a classic computer science problem that involves finding the longest sequence of characters that appear in the same order in both strings, but not necessarily consecutively. Here's a Python function that implements a dynamic programming approach to solve this problem:\n\n```python\ndef longest_common_subsequence(str1, str2):\n    # Get the lengths of the two strings\n    m = len(str1)\n    n = len(str2)\n    \n    # Create a 2D array to store lengths of longest common subsequence.\n    # Initialize it with zeros.\n    lcs_table = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build the lcs_table[m+1][n+1] in bottom up fashion\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                lcs_table[i][j] = 0\n            elif str1[i - 1] == str2[j - 1]:\n                lcs_table[i][j] = lcs_table[i - 1][j - 1] + 1\n            else:\n                lcs_table[i][j] = max(lcs_table[i - 1][j], lcs_table[i][j - 1])\n    \n    # The length of the LCS is stored in lcs_table[m][n]\n    lcs_length = lcs_table[m][n]\n    \n    # To get the actual LCS, we need to backtrack through the table\n    lcs = [\"\"] * lcs_length\n    i = m\n    j = n\n    index = lcs_length - 1\n    \n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            lcs[index] = str1[i - 1]\n            i -= 1\n            j -= 1\n            index -= 1\n        elif lcs_table[i - 1][j] > lcs_table[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    # Join the list to form the LCS string\n    return \"\".join(lcs)\n\n# Example usage:\nstr1 = \"ABCDEF\"\nstr2 = \"AEBDF\"\nprint(\"Longest Common Subsequence:\", longest_common_subsequence(str1, str2))\n```\n\n### Explanation:\n1. **Initialization**: We create a 2D array `lcs_table` with dimensions `(m+1) x (n+1)`, where `m` and `n` are the lengths of the two strings. This table will store the lengths of the longest common subsequences for all substrings of `str1` and `str2`.\n\n2. **Filling the Table**: We iterate through both strings and fill the table. If the characters match, we increment the value from the diagonal cell. If they don't match, we take the maximum value from the left or top cell.\n\n3. **Backtracking**: Once the table is filled, we backtrack from `lcs_table[m][n]` to construct the LCS string. We start from the bottom-right corner of the table and move towards the top-left, appending characters to the LCS list when we find a match.\n\n4. **Returning the Result**: Finally, we join the list of characters to form the LCS string and return it.\n\n### Example Output:\nFor the strings `\"ABCDEF\"` and `\"AEBDF\"`, the function will output:\n```\nLongest Common Subsequence: ABDF\n```"
      }
    ]
  },
  "algo-6": {
    "messages": [
      {
        "role": "assistant",
        "content": "To validate if a string of parentheses is balanced, you can use a stack-based approach. Here's a Python function that does this:\n\n```python\ndef is_balanced_parentheses(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            # Ignore characters that are not parentheses\n            continue\n    \n    return not stack\n\n# Example usage:\nprint(is_balanced_parentheses(\"()\"))          # True\nprint(is_balanced_parentheses(\"()[]{}\"))      # True\nprint(is_balanced_parentheses(\"(]\"))          # False\nprint(is_balanced_parentheses(\"([)]\"))        # False\nprint(is_balanced_parentheses(\"{[]}\"))        # True\nprint(is_balanced_parentheses(\"\"))            # True\n```\n\n### Explanation:\n- **Stack**: We use a stack to keep track of opening parentheses.\n- **Mapping**: We define a dictionary that maps each closing parenthesis to its corresponding opening parenthesis.\n- **Iteration**: We iterate through each character in the string:\n  - If the character is an opening parenthesis (`(`, `{`, `[`), we push it onto the stack.\n  - If the character is a closing parenthesis (`)`, `}`, `]`), we check if the stack is empty or if the top element of the stack does not match the corresponding opening parenthesis. If either condition is true, the string is not balanced.\n  - If the character is not a parenthesis, we ignore it.\n- **Final Check**: After processing all characters, if the stack is empty, the string is balanced. If not, it means there are unmatched opening parentheses.\n\nThis function works for strings containing only parentheses, but you can easily extend it to handle other types of brackets or even mixed content by adjusting the `mapping` dictionary and the conditions in the loop."
      }
    ]
  },
  "algo-7": {
    "messages": [
      {
        "role": "assistant",
        "content": "Certainly! You can merge two sorted lists into one sorted list by iterating through both lists and comparing their elements. Here's a Python function that does this:\n\n```python\ndef merge_sorted_lists(list1, list2):\n    merged_list = []\n    i, j = 0, 0\n\n    # Traverse both lists and append the smaller element to the merged list\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        else:\n            merged_list.append(list2[j])\n            j += 1\n\n    # If there are remaining elements in list1, append them\n    while i < len(list1):\n        merged_list.append(list1[i])\n        i += 1\n\n    # If there are remaining elements in list2, append them\n    while j < len(list2):\n        merged_list.append(list2[j])\n        j += 1\n\n    return merged_list\n\n# Example usage:\nlist1 = [1, 3, 5, 7]\nlist2 = [2, 4, 6, 8]\nresult = merge_sorted_lists(list1, list2)\nprint(result)  # Output: [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nThis function works by using two pointers, `i` and `j`, to traverse `list1` and `list2` respectively. It compares the elements at these pointers and appends the smaller one to the `merged_list`. Once one of the lists is fully traversed, the remaining elements from the other list are appended to `merged_list`. The result is a single sorted list containing all elements from both input lists."
      }
    ]
  },
  "algo-8": {
    "messages": [
      {
        "role": "assistant",
        "content": "Certainly! Below is a Python implementation of Dijkstra's shortest path algorithm using a priority queue (min-heap) to efficiently select the next node with the smallest tentative distance.\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    # Initialize distances with infinity and set the distance to the start node to 0\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to hold nodes to be processed\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        # Get the node with the smallest distance\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # If the current distance is greater than the recorded distance, skip processing\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Visit each neighbor of the current node\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            \n            # If a shorter path is found, update the distance and add to the queue\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\n# Example usage:\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\nstart_node = 'A'\nshortest_paths = dijkstra(graph, start_node)\nprint(f\"Shortest paths from {start_node}: {shortest_paths}\")\n```\n\n### Explanation:\n- **Graph Representation**: The graph is represented as a dictionary of dictionaries, where each key is a node, and the value is another dictionary mapping neighboring nodes to the edge weights.\n- **Distances Dictionary**: This dictionary keeps track of the shortest distance from the start node to each node in the graph. Initially, all distances are set to infinity except for the start node, which is set to 0.\n- **Priority Queue**: A min-heap is used to always process the node with the smallest tentative distance next. This is implemented using Python's `heapq` module.\n- **Algorithm Steps**:\n  1. Pop the node with the smallest distance from the priority queue.\n  2. If the distance is greater than the recorded distance, skip processing.\n  3. For each neighbor, calculate the tentative distance and update the distances dictionary if a shorter path is found.\n  4. Push the updated distance and neighbor onto the priority queue.\n- **Return Value**: The function returns the `distances` dictionary, which contains the shortest path from the start node to each node in the graph.\n\n### Example Output:\nFor the provided example graph, the output will be:\n```\nShortest paths from A: {'A': 0, 'B': 1, 'C': 3, 'D': 4}\n```\n\nThis indicates that the shortest path from node 'A' to node 'D' has a total weight of 4."
      }
    ]
  }
}